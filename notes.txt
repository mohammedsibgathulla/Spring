1. Quick Introduction to Spring Framework
Dependency Injection solves the problem of tight coupling of code.
@Component - Spring manages the instances of the classes using the @Component.
@Autowired - Spring will autowire the dependency and populate it.

Important Terminology of Spring Framework
1. Beans - Differenct objects managed by spring framework.
2. Autowiring - Process where spring identifies the dependencies and identifies the matches for the dependencies and populates them.
3. Dependency Injection - Dependency Injection solves the problem of tight coupling of code and we don't need to instantiate the classes.
4. Inversion of Control - We are taking the control from the class which needs the dependency and giving the control to the spring framework.
5. IOC Container - It is a generic terminology to represent anything that is implementing IOC.
6. Application Context - In Spring Application Context is the IOC Container.

2. Setting Up Spring Boot Project Using http://start.spring.io
1. Just download the basic spring boot project without any dependencies.

3. Understanding the tight coupling.
- See the project.

4. Using Spring Framework To Manage Dependencies - @Component, @Autowired
- @springBootApplication tells spring to scan the package and subpackages in which it is declared.

5. Dynamic Auto Wiring
- When a dependency has more than one bean then we need to specify which bean to be used as primary during autowiring.
@Primary - It is used to specify a bean as primary when we have two beans of same implementation.

6. Constructor & Setter Injection
Constuctor - Autowiring by type from bean name  via constructor 
Setter -  Autowiring by type from bean name 'binarySearchImpl' to bean named 'bubbleSortAlgorithm'
No Setter or Constructor - Autowiring by type from bean name 'binarySearchImpl' to bean named 'bubbleSortAlgorithm'

7. Spring Modules
- Spring has different modules Core Container, Data Access / Integration, Web.
- Test, AOP, Aspects, Instrumentation, Messaging (These are called as cross cutting modules as they are applicable to more than one layer).

8. Spring Projects
- See the image.

9. Dependency Injection Few More Examples
ToDoController(Web Layer) (@Autowired)-> ToDoDataService(Business Layer) (@Autowired)-> (Data Layer) JdbcTemplate

10. Autowiring In Depth By Name & @Primary
- You can just use bean name of any bean implementing the interface and autowire it instead of @Primary annotation.
- If you use both name and @Primary the preference will be give to @Primary and that particular bean is used in the autowiring.

11. Autowiring In Depth @Qualifer Annotation
- @Qualifier("quick") you have to use it on both the dependency and the bean name which u want to use for autowiring.

12. Scope Of A Bean - Prototype & Singleton
- @Scope(ConfigurableBeanFactory.SCOPE_SINGLETON) singleton Bean - One instance per Spring Context (In Spring by default any bean is a singleton bean).
- @Scope("prototype") / @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE): prototype Bean - U will get a new bean when ever requested.
- request - One bean per HTTP request.
- session - One bean per HTTP session.

13. Complex Scope Scenarios Of A Spring Bean Mix Prototype and Singleton
- When you use singleton with the bean and if dependency bean has prototype it will not be implemented hence in order to apply it we need to configure the proxy on the dependency bean.
- @Scope(value=ConfigurableBeanFactory.SCOPE_PROTOTYPE, proxyMode = ScopedProxyMode.TARGET_CLASS)

14. Difference Between Spring Singleton & GOF (Gang Of Four) Singleton
- GOF Singleton is one Singleton per JVM even if u have multiple Application Contexts are running in the same JVM u should have once instance of that specific class.
- In Spring one Instance per Application Context if you have 5 Application Context a hypothetical scenario then u will have 5 instances.

15. Using Component Scan To Scan For Beans
- @ComponentScan("package") This annotation will scan the beans from the package u have specified. If u specify the root pacakge then all the beans will be scanned.
- @SpringBootApplication This will scan for the beans in the current package.

16. Lifecycle Of A Bean - @PostConstruct And @PreDestroy
- The entire life cycle of bean is managed by the Spring IOC container.
@PostConstruct: Do certain things during the creation of the bean. The post construct is called after the dependencies and autowiring is done.
@PostDestroy: Do certaion things before the bean is destroyed.

17. Container / Context & Dependency Injection (CDI) - @Named, @Inject
- CDI is Java EE Dependency Injection Standard
- Spring supports most annotations
@Inject (@Autowired)
@Named (@Component & @Qualifer) 
@Singleton (Defines a scope of Singleton)
- You need to add the dependency of maven in pom.xml in order to use the above annotations.

18. Removing Spring Boot In Basic Application
@Configuration & @ComponentScan are used instead of @SpringBootApplication to initialize the Application Context in java way instead of SpringBoot.
- See the project for more details.

19. Defining Spring Application Context Using XML
- If we use xml approach the file will have a lot of lines due to which it will be very difficult to maintain.
- See the project for more details.

20. Mixing XML Context With Component Scan For Beans Defined With Annotation
- <context:component-scan base-package="com.spring.basics"></context:component-scan> By defining the code the spring will scan all the beans including the annotated beans and as well as xml defined beans in the project.

21. IOC Container vs Application Context vs Bean Factory
IOC Container: It is a generic terminology to represent anything that is implementing IOC.
Bean Factory: It provides basic management of beans and wiring of dependencies. It is used in devices where the memory is very less like (IOT devices)
Application Context: Bean Factory ++, Spring AOP Features, I18n capabilites, Web Application Context for web Applications etc. 

22. @Component vs @Service vs @Repository vs @Controller
The below are the different stereotypes where are present in the spring.
@Component: Generic Component
@Service: Business Service Facade
@Repository: Encapsulating Storage, retrival and search behaviour typically from a relational database
@Controller: It is used to define a controller in the web layer (Controller in MVC Pattern)
By defining these annotations you can apply different logic
You want to log everything coming into your business layer in that kind of scenario you will be able to identify everything that has an @service annotation you can use AOP to identify that and you can log all the content.












